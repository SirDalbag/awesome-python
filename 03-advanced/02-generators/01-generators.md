# Генераторы в Python

Генераторы в Python — это удобный способ создания итераторов. Они позволяют вам создавать последовательности значений на лету, без необходимости загружать их все в память одновременно. Это делает их полезными для работы с большими данными или бесконечными последовательностями.

## Основы генераторов

Генераторы создаются с помощью ключевого слова `yield` в функции. Каждый раз, когда функция с `yield` вызывается, она возвращает значение и сохраняет свое состояние, позволяя возобновить выполнение с этого места при следующем вызове.

```python
def simple_generator():
    yield 1
    yield 2
    yield 3

gen = simple_generator()

print(next(gen))  # 1
print(next(gen))  # 2
print(next(gen))  # 3
```

## Генераторы и итераторы

Генераторы автоматически реализуют протокол итератора. Это означает, что они могут быть использованы в циклах `for`, с функциями, такими как `sum()`, `list()`, и другими контекстами, где требуется итератор.

```python
def countdown(n):
    while n > 0:
        yield n
        n -= 1

for number in countdown(5):
    print(number)
```

## Генераторные выражения

Генераторные выражения похожи на списковые включения, но вместо создания списка они создают генератор. Они используют круглые скобки вместо квадратных.

```python
gen = (x * x for x in range(10))

for value in gen:
    print(value)
```

## Преимущества генераторов

1) Экономия памяти: Генераторы создают элементы на лету и не хранят их в памяти.
2) Ленивые вычисления: Генераторы вычисляют значения по мере необходимости, что делает их полезными для работы с большими и потенциально бесконечными данными.
3) Простота реализации: Генераторы позволяют легко создавать итераторы без необходимости реализации всех методов класса итератора.

## Передача значений в генераторы

Генераторы поддерживают отправку значений обратно в генератор с помощью метода `send()`. Это позволяет вам взаимодействовать с генератором в процессе его выполнения.

```python
def accumulator():
    total = 0
    while True:
        value = yield total
        if value is None:
            break
        total += value

gen = accumulator()
print(next(gen))  # 0
print(gen.send(10))  # 10
print(gen.send(20))  # 30
gen.close()
```

## Обработка исключений в генераторах

Генераторы могут обрабатывать исключения, отправленные в них с помощью метода `throw()`. Это позволяет вам управлять поведением генератора при возникновении ошибок.

```python
def controlled_generator():
    try:
        yield "Начало"
        yield "Середина"
    except Exception as e:
        yield f"Ошибка: {e}"
    finally:
        yield "Конец"

gen = controlled_generator()
print(next(gen))  # Начало
print(next(gen))  # Середина
print(gen.throw(Exception, "Что-то пошло не так"))  # Ошибка: Что-то пошло не так
print(next(gen))  # Конец
```

## Пример комплексного использования генераторов

```python
def fibonacci():
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

fib_gen = fibonacci()

for _ in range(10):
    print(next(fib_gen))

# Генераторное выражение для фильтрации чисел Фибоначчи, делящихся на 2
even_fibs = (x for x in fibonacci() if x % 2 == 0)

for _ in range(5):
    print(next(even_fibs))
```

